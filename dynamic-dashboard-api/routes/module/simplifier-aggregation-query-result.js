// File: simplifier-aggregation-query-result.js

/**
 * Parses the Elasticsearch aggregation result into a format suitable for ECharts graphs.
 * @param {Object} result - The Elasticsearch aggregation result.
 * @param {Object} mapping - The mapping object generated by the query builder.
 * @param {string} graphType - The type of ECharts graph to generate data for.
 * @returns {Object} An object containing data suitable for the specified ECharts graph type.
 */

function parseAggregationResult(result, mapping, graphType = 'data_table') {
    // console.log("Entering parseAggregationResult with graphType:", graphType);
    let parsedResult;
    switch (graphType) {
        case 'data_table':
            parsedResult = parseForDataTable(result, mapping);
            break;
        case 'bar_horizontal':
        case 'bar_vertical':
        case 'bar_horizontal_stacked':
        case 'bar_vertical_stacked': 
        case 'bar_vertical_percentage':
        case 'bar_horizontal_percentage':
        case 'line':
            parsedResult = parseForBarOrLine(result, mapping, graphType);
            break;
        case 'pie':
            parsedResult = parseForPie(result, mapping);
            break;
        case 'sunburst':
            parsedResult = parseForSunburst(result, mapping);
            break;
        default:
            throw new Error(`Unsupported graph type: ${graphType}`);
    }
    console.log("", JSON.stringify(parsedResult, null, 2));
    return parsedResult;
}




function parseForDataTable(result, mapping) {
    const parsedResults = [];

    function traverse(currentResult, currentMapping, currentPath = {}) {
        if (!currentMapping) return;

        Object.keys(currentMapping).forEach(key => {
            const aggInfo = currentMapping[key];
            const aggResult = currentResult?.aggregations?.[key] ?? currentResult?.[key];

            if (aggInfo.axisType === 'main_axis') {
                if (aggResult && aggResult.buckets) {
                    aggResult.buckets.forEach(bucket => {
                        const newPath = { 
                            ...currentPath, 
                            [aggInfo.aggNum]: bucket.key,
                            [`${aggInfo.aggNum}_doc_count`]: bucket.doc_count

                        };
                        if (aggInfo.child) {
                            traverse(bucket, aggInfo.child, newPath);
                        } else {
                            parsedResults.push(newPath);
                        }
                    });
                }
            } else if (aggInfo.axisType === 'value_axis') {
                Object.keys(currentMapping).forEach(valueKey => {
                    const valueAggInfo = currentMapping[valueKey];
                    if (valueAggInfo.axisType === 'value_axis') {
                        const valueResult = currentResult[valueKey];
                        currentPath[valueAggInfo.aggNum] = valueResult ? valueResult.value : null;
                    }
                });
                parsedResults.push(currentPath);
            }
        });
    }

    traverse(result.aggregations, mapping);
    return parsedResults;
}

function parseForBarOrLine(result, mapping, graphType) {
    const xAxisData = [];
    const seriesData = {};
    let valueAxisCount = 0;

    // console.log("Mapping:", JSON.stringify(mapping, null, 2));
    // console.log("Result aggregations:", JSON.stringify(result.aggregations, null, 2));

    function traverse(currentResult, currentMapping) {
        if (!currentMapping) return;

        Object.keys(currentMapping).forEach(key => {
            const aggInfo = currentMapping[key];
            const aggResult = currentResult?.aggregations?.[key] ?? currentResult?.[key];

            // console.log(`Processing key: ${key}, aggInfo:`, JSON.stringify(aggInfo, null, 2));
            // console.log(`AggResult:`, JSON.stringify(aggResult, null, 2));

            if (aggInfo.axisType === 'main_axis') {
                if (aggResult && aggResult.buckets) {
                    aggResult.buckets.forEach(bucket => {
                        xAxisData.push(bucket.key);
                        // console.log(`Added to xAxisData: ${bucket.key}`);
                        
                        // Process value_axis aggregations from the 'child' property
                        if (aggInfo.child) {
                            Object.keys(aggInfo.child).forEach(childKey => {
                                const childAggInfo = aggInfo.child[childKey];
                                if (childAggInfo.axisType === 'value_axis') {
                                    valueAxisCount++;
                                    const seriesName = `Value ${childAggInfo.aggNum}`;
                                    if (!seriesData[seriesName]) {
                                        seriesData[seriesName] = [];
                                    }
                                    const value = bucket[childKey]?.value ?? null;
                                    seriesData[seriesName].push(value);
                                    // console.log(`Added to seriesData[${seriesName}]: ${value}`);
                                }
                            });
                        }
                    });
                }
            }
        });
    }

    traverse(result.aggregations, mapping);

    // console.log("Final xAxisData:", xAxisData);
    // console.log("Final seriesData:", JSON.stringify(seriesData, null, 2));

    let defaultStackName = '';

    let percentages = false;
    const totalData = [];

    if(graphType=='bar_vertical_percentage' || graphType=='bar_horizontal_percentage')
    {
        percentages = true;
        const seriesData_array = Object.values(seriesData);
        
        for (let i = 0; i < seriesData_array[0].length; ++i) {
        let sum = 0;
        for (let j = 0; j < seriesData_array.length; ++j) {
            sum += seriesData_array[j][i];
        }
        totalData.push(sum);
        }
        // console.log("Final totalData:", JSON.stringify(totalData, null, 2));
    }
    

   

    if(graphType=="bar_vertical_stacked" || graphType=="bar_horizontal_stacked" || graphType=='bar_vertical_percentage' || graphType=='bar_horizontal_percentage' )
    {
        defaultStackName = 'stack';
    }

    const useStack = valueAxisCount > 1;
    let xType = "category";
    let yType = "value";
    let gT = 'bar';

    if(graphType=="line")
    {
            gT = 'line';
    }

    if(graphType=="bar_horizontal" || graphType=="bar_horizontal_stacked" )
    {
         xType = "value";
         yType = "category";
    }
    
    return {
        xAxis: {
            type: xType,
            data: xAxisData
        },
        yAxis: {
            type: yType
        },
        legend: {},
        tooltip: {
            trigger: 'axis'
          },


        series: Object.keys(seriesData).map((name, index) => ({
            name: name,
           
            label: {show : (percentages) ? true : false },
               
            data: (percentages) ? seriesData[name].map((d, did) =>
                totalData[did] <= 0 ? 0 : Math.round(d / totalData[did] *100)
              )
              : seriesData[name],

            emphasis: {
                focus: (graphType=="line") ? 'series' : 'none'
              },
            type: gT,
            ...(useStack && { stack: defaultStackName })
        }))
    };
}

function parseForPie(result, mapping) {
    const data = [];

    function traverse(currentResult, currentMapping, path = []) {
        if (!currentMapping) return;

        Object.keys(currentMapping).forEach(key => {
            const aggInfo = currentMapping[key];
            const aggResult = currentResult?.aggregations?.[key] ?? currentResult?.[key];

            if (aggInfo.axisType === 'main_axis') {
                if (aggResult && aggResult.buckets) {
                    aggResult.buckets.forEach(bucket => {
                        const newPath = [...path, bucket.key];
                        if (aggInfo.child) {
                            traverse(bucket, aggInfo.child, newPath);
                        } else {
                            // We've reached the deepest level, add to data
                            const name = newPath.join(' - ');
                            const value = bucket.doc_count;
                            data.push({ name, value });
                        }
                    });
                }
            } else if (aggInfo.axisType === 'value_axis') {
                // We've reached a value_axis, use its value for the pie slice
                const name = path.join(' - ');
                const value = aggResult?.value ?? 0; // Use 0 if value is null
                data.push({ name, value });
            }
        });
    }

    traverse(result.aggregations, mapping);

    return {
        series: [{
            type: 'pie',
            data: data
        }]
    };
}


function parseForSunburst(result, mapping) {
    function traverse(currentResult, currentMapping, path = []) {
        if (!currentMapping) return null;

        let children = [];
        let value = 0;

        Object.keys(currentMapping).forEach(key => {
            const aggInfo = currentMapping[key];
            const aggResult = currentResult?.aggregations?.[key] ?? currentResult?.[key];

            if (aggInfo.axisType === 'main_axis') {
                if (aggResult && aggResult.buckets) {
                    aggResult.buckets.forEach(bucket => {
                        const newPath = [...path, bucket.key];
                        const child = traverse(bucket, aggInfo.child, newPath);
                        if (child) {
                            if (path.length === 0) {
                                // Top-level aggregation
                                children.push(child);
                            } else {
                                children.push({
                                    name: bucket.key,
                                    value: child.value,
                                    ...(child.children && child.children.length > 0 && { children: child.children })
                                });
                            }
                            value += child.value;
                        }
                    });
                }
            } else if (aggInfo.axisType === 'value_axis') {
                value = aggResult?.value ?? 0;
            }
        });

        if (path.length === 0) {
            // Return only children for the top level
            return children;
        }

        return {
            name: path[path.length - 1],
            value: value,
            ...(children.length > 0 && { children: children })
        };
    }

    const data = traverse(result.aggregations, mapping);

    return {
        series: [{
            type: 'sunburst',
            emphasis: {
                focus: 'ancestor'
              },
            tooltip: {
                "trigger" : "item"
            },  
            data: data,
            radius: [0, '90%'],
            label: {
                rotate: 'radial'
            }
        }]
    };
}

module.exports = { parseAggregationResult };